const btoa = require('btoa');
const qs = require('querystring');
const request = require('request-promise-native');

module.exports = class SpotifyApiClient {
  constructor(authToken, handleError) {
    this.authToken = authToken;
    this.handleError = handleError || console.error;
  }

  static getAuthorizeUrl(state) {
    const query = {
      client_id: process.env.SPOTIFY_CLIENT_ID,
      response_type: 'code',
      redirect_uri: process.env.SPOTIFY_REDIRECT_URI,
      scope:
        'playlist-read-collaborative playlist-read-private playlist-modify-private playlist-modify-public user-read-private',
      show_dialog: true,
      state,
    };

    return `https://accounts.spotify.com/authorize?${qs.stringify(query)}`;
  }

  static async authorize(code) {
    const token = btoa(`${process.env.SPOTIFY_CLIENT_ID}:${process.env.SPOTIFY_CLIENT_SECRET}`);

    return request({
      method: 'POST',
      uri: 'https://accounts.spotify.com/api/token',
      headers: {
        Accept: '*/*',
        Authorization: `Basic ${token}`,
        'Content-Type': 'application/x-www-form-urlencoded',
        'User-Agent': 'npmn/0.0.1',
      },
      body: qs.stringify({
        grant_type: 'authorization_code',
        code,
        redirect_uri: process.env.SPOTIFY_REDIRECT_URI,
      }),
      json: true,
    });
  }

  static async refresh(refresh_token) {
    const token = btoa(`${process.env.SPOTIFY_CLIENT_ID}:${process.env.SPOTIFY_CLIENT_SECRET}`);

    return request({
      method: 'POST',
      uri: 'https://accounts.spotify.com/api/token',
      headers: {
        Accept: '*/*',
        Authorization: `Basic ${token}`,
        'Content-Type': 'application/x-www-form-urlencoded',
        'User-Agent': 'npmn/0.0.1',
      },
      body: qs.stringify({
        grant_type: 'refresh_token',
        refresh_token,
      }),
      json: true,
    });
  }

  makeAuthenticatedRequest(method, uri, payload = {}) {
    const requestOptions = {
      method,
      uri: `https://api.spotify.com/v1/${uri}`,
      headers: {
        Authorization: `Bearer ${this.authToken}`,
      },
      json: true,
    };

    if (method === 'PATCH' || method === 'POST' || method === 'PUT') {
      requestOptions.body = payload;
    } else if (method === 'GET') {
      requestOptions.qs = payload;
    }

    return request(requestOptions);
  }

  async addAlbumToPlaylist(album, playlistId, tracks = []) {
    try {
      const { items } = await this.makeAuthenticatedRequest('GET', `albums/${album}/tracks`);

      const uris = [];

      items.forEach(({ id, uri }) => {
        if (tracks.indexOf(id) === -1) {
          uris.push(uri);
        }
      });

      if (uris.length) {
        await this.makeAuthenticatedRequest('POST', `playlists/${playlistId}/tracks`, { uris });
      }

      return uris;
    } catch (error) {
      this.handleError('Failed to add to playlist', error);
    }
  }

  async addTracksToPlaylist(uris, playlistId) {
    try {
      if (uris.length) {
        await this.makeAuthenticatedRequest('POST', `playlists/${playlistId}/tracks`, { uris });
      }

      return uris;
    } catch (error) {
      this.handleError('Failed to add to playlist', error);
    }
  }

  createPlaylist(user, name) {
    try {
      return this.makeAuthenticatedRequest('POST', `users/${user}/playlists`, {
        name,
        description: 'Automatically generated by nmpm',
        public: false,
      });
    } catch (error) {
      this.handleError('Failed to create new playlist', error);
    }
  }

  getPlaylist(playlistId) {
    try {
      return this.makeAuthenticatedRequest('GET', `playlists/${playlistId}`);
    } catch (error) {
      this.handleError('Failed to get playlist', error);
    }
  }

  async getPlaylistTracks(playlistId) {
    const tracks = [];
    let offset = 0;
    let hasNext = true;

    try {
      while (hasNext) {
        let options = {};
        if (offset) {
          options.offset = offset;
        }

        let { items, next } = await this.makeAuthenticatedRequest('GET', `playlists/${playlistId}/tracks`, options);
        tracks.push(...items.map(({ track: { id } }) => id));

        if (next) {
          offset = offset + 100;
        } else {
          hasNext = false;
        }
      }

      return tracks;
    } catch (error) {
      this.handleError('Failed to build playlist', error);
    }
  }

  getPlaylists() {
    try {
      return this.makeAuthenticatedRequest('GET', 'me/playlists', { limit: 50 });
    } catch (error) {
      this.handleError('Failed to fetch playlists', error);
    }
  }

  async getTracks(album) {
    const { items } = await this.makeAuthenticatedRequest('GET', `albums/${album}/tracks`);

    return items;
  }

  getUser() {
    try {
      return this.makeAuthenticatedRequest('GET', 'me');
    } catch (error) {
      this.handleError('Failed to get user information', error);
    }
  }

  async search(q, type) {
    try {
      const response = await this.makeAuthenticatedRequest('GET', 'search', { q, type });

      return response.albums.items;
    } catch (error) {
      this.handleError('Failed search', error);
    }
  }

  setAuthToken(authToken) {
    this.authToken = authToken;

    return this;
  }
};
